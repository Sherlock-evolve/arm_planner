一、需求分析
1、不使用 RViz 自带的 Motion Planning 插件
2、设计 Qt 图形界面 输入三维目标点和姿态，一键规划和执行
3、用C++实现自己的运动规划算法



二、总体思路

目标是实现一条完整的数据流：
Qt GUI → Qt Action Client → RRT算法实现 → MoveIt/控制器 → RViz可视化

要实现这个数据流的传输必须搞懂：
1. Qt 进程如何作为 ROS2 节点与 MoveIt 通信？
2. Qt 中的数值（x, y, z, Roll, Pitch, Yaw）如何转换为 MoveIt 能理解的消息和坐标格式？
3. MoveIt 收到目标位姿后，内部如何做 IK、碰撞检测、路径规划？
4. 规划结果如何真正驱动仿真机械臂运动？
5. 驱动结果（关节角度和轨迹）是如何被 RViz 订阅并显示出来的？



三、问题解决

Qt 进程如何作为 ROS2 节点与 MoveIt 通信？

1. 传统模式（使用 RViz Motion Planning 插件）
- 用户在 RViz 的 Motion Planning 面板中设置起点/终点，点击 Plan / Execute。
- 插件内部调用 MoveIt 的 C++ API（实质上还是通过 move_group 节点）。
- move_group 进行 IK、规划、碰撞检测，并将轨迹下发给控制器。
- 控制器 / 仿真发布 joint_states 和执行结果，RViz 订阅这些话题更新画面。

2. 自定义 Qt 模式
- Qt 程序内部创建一个 rclcpp::Node，相当于一个“发命令的 ROS2 节点”。
- 用户在 Qt 界面输入三维坐标和姿态，Qt 将这些数值封装为 ROS 消息，再通过 Action机制调用 MoveIt。
- 采用“Qt Action Client + C++ Action Server”的方式：
  - Qt 端：PlanExecutePose 动作客户端。
  - 服务端：MoveItMotionServer 节点，内部使用 MoveGroupInterface 调用 move_group。
- move_group 执行规划/执行逻辑后，通过控制器驱动虚拟机械臂，并发布 joint_states。
- RViz 通过订阅 joint_states 和 MoveIt 相关话题，仅作为“监视器”显示当前状态和规划结果。



Qt 中的数值（x, y, z, Roll, Pitch, Yaw）如何转换为 MoveIt 能理解的消息和坐标格式？

1. Qt 中的原始数据
- 位置：x, y, z，单位为米（m）。
- 姿态：欧拉角 Roll, Pitch, Yaw。单位为弧度 (rad)。

2. ROS/MoveIt 所需的数据格式
- 位姿使用 geometry_msgs::PoseStamped：
  - header.frame_id：参考坐标系名称（如 world 或 base_link）。
  - pose.position：x, y, z。
  - pose.orientation：四元数 (x, y, z, w)。

3. 欧拉角到四元数的转换
- Qt 中获取到 roll, pitch, yaw 后，需要通过 tf2 库进行转换：
  - tf2::Quaternion q; q.setRPY(roll, pitch, yaw);
  - target_pose.pose.orientation = tf2::toMsg(q);

4. Action 消息封装
- PlanExecutePose.action 中，Goal 部分包括：
  - target_pose：目标末端位姿 PoseStamped。
  - velocity_scaling, acceleration_scaling：速度和加速度缩放因子。
  - execute：是否在规划后立即执行。
  - wait_for_execution：是否同步等待执行完成。
- Qt 将 PoseStamped 和这些参数封装成 Goal，发送给 Action Server。



MoveIt 收到目标位姿后，内部如何做 IK、碰撞检测、路径规划？

1. 解析与基本校验
- 检查 header.frame_id 是否为空，若为空则使用默认参考系（如 world）。
- 检查 position 和 orientation 是否为有限值（非 NaN/Inf）。

2. 逆运动学求解（IK）
- MoveIt 会根据 SRDF 和 kinematics.yaml 中配置的 IK 插件（例如 KDL、IKFast、TRAC-IK 等）把末端位姿转换成一组关节角度。
- 求解问题可以表述为：给定末端位姿 T_base^ee，求关节向量 q，使 forward_kinematics(q) ≈ T_base^ee。
- 若 IK 求解失败（超出工作空间或奇异位姿），MoveIt 会返回错误码（如 NO_IK_SOLUTION），规划在此处直接失败。

【深入理解 IK 求解器的数据转换过程】
2.1 输入数据格式转换
- MoveIt 接收到的目标位姿是 geometry_msgs::Pose（包含 position 和 orientation 四元数）
- IK 求解器需要将其转换为齐次变换矩阵 T_base^ee（4x4 矩阵）：
  - 位置部分：从 pose.position (x, y, z) 直接提取
  - 姿态部分：从 pose.orientation (四元数 qx, qy, qz, qw) 转换为旋转矩阵 R
  - 组合成变换矩阵：T = [R | t; 0 0 0 | 1]

2.2 IK 插件加载机制
- MoveIt 通过 pluginlib 动态加载 IK 插件（配置在 kinematics.yaml）
- 插件必须实现 kinematics_interface::KinematicsBase 接口
- KDLKinematicsPlugin 使用 KDL（Kinematica and Dynamics Library）库

2.3 KDL IK 求解算法（数值方法）
- 使用 Levenberg-Marquardt 优化算法进行迭代求解
- 迭代过程：
  a) 初始化：q_current = 当前关节状态（或随机初始化）
  b) 计算误差：error = ||FK(q_current) - T_target||
  c) 计算雅可比矩阵：J = ∂FK/∂q（6xN 矩阵，N 为关节数）
  d) 更新关节角度：Δq = J^+ * error（使用伪逆或阻尼最小二乘）
  e) 检查收敛：如果 error < tolerance 或达到最大迭代次数，停止
- 参数影响：
  - kinematics_solver_search_resolution：搜索分辨率，影响求解精度
  - kinematics_solver_timeout：超时时间，防止无限迭代

2.4 IK 求解结果验证
- IK 求解成功后，得到关节角度向量 q = [q1, q2, ..., qn]
- 需要验证：使用正运动学 FK(q) 计算末端位姿，检查是否接近目标位姿
- 误差检查：位置误差 < 1mm，姿态误差 < 0.01 rad（可配置）

2.5 IK 求解失败的原因
- 目标位姿超出工作空间：无法通过任何关节角度组合达到
- 奇异位姿：雅可比矩阵奇异，无法求解
- 关节限制冲突：求解出的关节角度超出 URDF 定义的关节限制
- 数值求解失败：迭代不收敛或超时

3. 碰撞检测与约束检查
- MoveIt 维护一个 Planning Scene，其中包含机器人模型和环境障碍物。
- 在起始状态和目标状态上进行碰撞检测：
  - 起始状态是否碰撞 (START_STATE_IN_COLLISION)。
  - 目标状态是否碰撞 (GOAL_IN_COLLISION)。
- 同时检查关节范围、路径约束等是否满足。

【深入理解碰撞检测的具体实现机制】
3.1 Planning Scene 的构建
- Planning Scene 包含：
  a) 机器人模型：从 URDF 加载，包含所有 link 和 joint 的几何信息
  b) 碰撞对（Collision Pairs）：从 SRDF 加载，定义哪些 link 之间不需要碰撞检测（如相邻 link）
  c) 环境障碍物：可以动态添加的障碍物（如桌面、墙壁等）
- Planning Scene 使用 FCL（Flexible Collision Library）进行碰撞检测

3.2 碰撞检测的数据转换
- 输入：关节状态 q = [q1, q2, ..., qn]
- 转换过程：
  a) 使用正运动学计算每个 link 的位姿：T_base^link_i = FK_i(q)
  b) 将每个 link 的几何形状（从 URDF 的 collision 标签）变换到世界坐标系
  c) 使用 FCL 进行碰撞检测
- 输出：碰撞检测结果（是否碰撞、碰撞的 link 对、碰撞点等）

3.3 FCL 碰撞检测算法
- FCL 支持多种几何形状：Box、Sphere、Cylinder、Mesh 等
- 碰撞检测方法：
  a) 粗检测（Broad Phase）：使用 AABB（Axis-Aligned Bounding Box）快速过滤
  b) 精检测（Narrow Phase）：使用 GJK/EPA 算法进行精确碰撞检测
- 性能优化：
  - 使用碰撞对过滤（SRDF 中定义）跳过不需要检测的 link 对
  - 使用空间哈希或 BVH（Bounding Volume Hierarchy）加速

3.4 碰撞检测的调用时机
- 起始状态碰撞检测：在规划开始前，检查当前关节状态是否碰撞
- 目标状态碰撞检测：在 IK 求解成功后，检查目标关节状态是否碰撞
- 路径碰撞检测：在路径规划过程中，对每个采样点进行碰撞检测
- 连续碰撞检测：检查两个状态之间的运动路径是否碰撞（使用 swept volume）

3.5 碰撞检测结果的处理
- 如果起始状态碰撞：返回 START_STATE_IN_COLLISION 错误
- 如果目标状态碰撞：返回 GOAL_IN_COLLISION 错误
- 如果路径中某点碰撞：规划器会尝试绕过该点或重新规划

4. 路径规划与时间参数化
- 在合法的起始关节状态和目标关节状态之间，调用规划器（通常为 OMPL ，如 RRTConnect）搜索一条无碰撞的轨迹。
- 规划时会考虑：
  - 关节速度、加速度限制（来自 joint_limits.yaml）。
  - 用户输入的速度/加速度缩放因子。
  - 规划时间上限等参数。
- 规划成功后先得到几何路径，再通过时间参数化插件（如 Iterative Parabolic Time Parameterization）为每个路径点分配时间戳和速度/加速度，使轨迹满足动态约束。

【深入理解路径规划的具体过程】
4.1 规划问题的数据转换
- 输入：
  a) 起始关节状态：q_start = [q1_start, ..., qn_start]（从当前状态获取）
  b) 目标关节状态：q_goal = [q1_goal, ..., qn_goal]（从 IK 求解得到）
  c) 约束：关节限制、碰撞约束、路径约束
- 配置空间（C-Space）定义：
  - 状态空间：每个关节的角度范围 [q_min, q_max]
  - 状态：n 维向量 q ∈ R^n
  - 有效状态：满足关节限制且无碰撞的状态

4.2 OMPL 规划器配置（以 RRTConnect 为例）
- 配置来源：ompl_planning.yaml
- 关键参数：
  - range：每次扩展的最大距离
  - goal_bias：向目标扩展的概率（0-1）
  - planning_time_limit：规划时间上限
- Request Adapters 预处理：
  - FixStartStateBounds：修正起始状态，确保在关节限制内
  - FixStartStateCollision：修正起始状态，避免碰撞
  - FixWorkspaceBounds：修正工作空间边界

4.3 RRTConnect 算法流程
- RRTConnect 是双向 RRT（Rapidly-exploring Random Tree）算法
- 算法步骤：
  a) 初始化：创建两棵树 T_start 和 T_goal，分别从起始状态和目标状态开始
  b) 迭代过程（直到连接成功或超时）：
     - 随机采样：在配置空间中随机采样一个状态 q_rand
     - 扩展 T_start：找到 T_start 中离 q_rand 最近的节点 q_near，向 q_rand 扩展得到 q_new
     - 碰撞检测：检查 q_near 到 q_new 的路径是否无碰撞
     - 如果无碰撞，将 q_new 加入 T_start
     - 扩展 T_goal：类似地扩展 T_goal
     - 连接检查：检查两棵树是否可以通过无碰撞路径连接
  c) 路径提取：如果连接成功，从起始状态到目标状态提取路径
- 输出：几何路径（一系列关节状态点），不包含时间信息

4.4 时间参数化（Time Parameterization）
- 输入：几何路径（waypoints），每个点只有位置信息
- 目标：为每个点分配时间戳、速度、加速度
- Iterative Parabolic Time Parameterization 算法：
  a) 初始时间分配：根据最大速度限制，为每段路径分配初始时间
  b) 迭代优化：
     - 检查每段路径是否满足速度限制
     - 检查每个点是否满足加速度限制
     - 如果不满足，增加时间间隔，重新计算
  c) 考虑约束：
     - 关节速度限制：|dq/dt| ≤ v_max * velocity_scaling
     - 关节加速度限制：|d²q/dt²| ≤ a_max * acceleration_scaling
- 输出：时间参数化轨迹，每个点包含：
  - 时间戳：t_i
  - 位置：q_i
  - 速度：dq_i/dt（可选）
  - 加速度：d²q_i/dt²（可选）

4.5 规划结果的数据结构
- moveit_msgs::MotionPlanResponse 包含：
  - trajectory：trajectory_msgs::JointTrajectory
    - joint_names：关节名称列表
    - points：轨迹点列表
      - positions：关节角度 [q1, q2, ..., qn]
      - velocities：关节速度（可选）
      - accelerations：关节加速度（可选）
      - time_from_start：从开始的时间戳
  - planning_time：规划耗时
  - error_code：错误码



规划结果如何真正驱动仿真机械臂运动？

1. 在 MoveItMotionServer 中的处理逻辑
- 根据 Qt 发送的 Goal：
  - 如果 execute=false：只调用 plan()，不执行，将“规划成功/失败”的结果返回给 Qt 用于显示。
  - 如果 execute=true：在规划成功后调用 execute() 或 asyncExecute()，下发轨迹给控制器。
- 在执行前后检查是否有 cancel 请求，以支持在 Qt 端“停止执行”。

2. 控制器与机械臂的关系
- 真机模式：控制器（如 FollowJointTrajectory 控制器）把 joint trajectory 转换为底层驱动指令，驱动伺服电机运动。
- 仿真模式（当前）：fake controller 按轨迹发布 joint_states，使 RViz 中的虚拟机械臂跟随运动。



驱动结果（关节角度和轨迹）是如何被 RViz 订阅并显示出来的？

1. 关节状态（Joint States）
- 控制器 / 仿真节点持续发布 sensor_msgs/JointState 到 /joint_states 话题。
- robot_state_publisher 订阅 /joint_states 和 URDF，计算出每个 link 在 TF 树中的位姿，并发布到 /tf、/tf_static。
- RViz 中的 RobotModel 或 Scene Robot Display 订阅这些 TF 和 robot_description，实时更新机械臂模型。

2. 规划结果可视化
- MoveIt 在规划成功后发布 moveit_msgs/DisplayTrajectory 到 /display_planned_path。
- RViz 的 MotionPlanning 插件或 DisplayTrajectory 插件订阅该话题，显示规划路径（通常是半透明的机器人轨迹）。


【深入理解 RViz 接收到的数据格式】
1.1 /joint_states 话题数据格式
- 消息类型：sensor_msgs::JointState
- 数据结构：
  - header：时间戳和坐标系
  - name：关节名称列表 ["joint1", "joint2", ...]
  - position：关节角度（弧度）[q1, q2, ...]
  - velocity：关节速度（可选）[dq1/dt, dq2/dt, ...]
  - effort：关节力矩（可选）
- 发布频率：通常 50-100 Hz（取决于控制器配置）
- 发布者：fake controller 或真实控制器

1.2 robot_state_publisher 的数据转换
- 输入：/joint_states 和 URDF
- 转换过程：
  a) 解析 URDF，构建机器人运动学模型
  b) 对于每个 joint，根据 joint 类型（revolute, prismatic 等）和当前关节角度，计算子 link 相对于父 link 的变换
  c) 通过 TF 树传播，计算每个 link 在 base_link 坐标系下的位姿
- 输出：发布到 /tf 和 /tf_static
  - /tf：动态变换（随时间变化）
  - /tf_static：静态变换（固定不变，如 base_link → world）

1.3 RViz RobotModel Display 的渲染流程
- 订阅话题：
  - /robot_description：URDF 字符串（机器人模型定义）
  - /tf 和 /tf_static：坐标系变换
- 渲染过程：
  a) 解析 URDF，构建 3D 模型（使用 urdf_parser 和 visualization_msgs::Marker）
  b) 订阅 TF，获取每个 link 的当前位姿
  c) 使用 OpenGL 渲染每个 link 的几何形状
  d) 实时更新：每当收到新的 TF，重新渲染模型
- 显示内容：
  - 橙色模型：当前状态（从 /tf 获取）
  - 半透明模型：规划轨迹（从 /display_planned_path 获取）

2.1 /display_planned_path 话题数据格式
- 消息类型：moveit_msgs::DisplayTrajectory
- 数据结构：
  - model_id：机器人模型 ID
  - trajectory：trajectory_msgs::JointTrajectory（规划轨迹）
  - trajectory_start：moveit_msgs::RobotState（起始状态）
- 发布时机：规划成功后立即发布
- 发布者：MoveIt move_group 节点

2.2 RViz DisplayTrajectory 插件的渲染
- 订阅话题：/display_planned_path
- 渲染过程：
  a) 解析 DisplayTrajectory 消息，提取轨迹点
  b) 对于每个轨迹点，使用正运动学计算末端位姿
  c) 在 RViz 中显示半透明的机器人模型序列
- 显示效果：
  - 半透明模型：表示规划路径上的机器人状态
  - 颜色编码：可以显示速度、加速度等信息













