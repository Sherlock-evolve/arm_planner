# 完整数据流详解：从 Qt 输入到 RViz 可视化

## 一、整体数据流图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Qt 图形界面 (QtArmWindow)                      │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 用户输入: x, y, z, Roll, Pitch, Yaw                              │   │
│  │ 单位: 米(m), 弧度(rad)                                            │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            ↓ 数据封装                                     │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ QtMoveItClient::sendGoal()                                        │   │
│  │ 1. 欧拉角 → 四元数: tf2::Quaternion::setRPY()                    │   │
│  │ 2. 封装 geometry_msgs::PoseStamped                                │   │
│  │ 3. 封装 PlanExecutePose::Goal                                     │   │
│  └──────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                            ↓ ROS2 Action
┌─────────────────────────────────────────────────────────────────────────┐
│                    MoveItMotionServer (Action Server)                    │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ handle_goal() → handle_accepted() → execute()                   │   │
│  │ 1. 数据验证 (NaN/Inf 检查)                                       │   │
│  │ 2. 设置目标位姿: move_group_->setPoseTarget()                    │   │
│  └──────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                            ↓ MoveGroupInterface
┌─────────────────────────────────────────────────────────────────────────┐
│                        MoveIt 内部处理流程                                │
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 步骤 1: 坐标变换                                                  │   │
│  │ 输入: geometry_msgs::Pose (frame_id: world)                      │   │
│  │ 处理: TF2 坐标变换到 base_link                                    │   │
│  │ 输出: T_base^ee (4x4 齐次变换矩阵)                                │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            ↓                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 步骤 2: 逆运动学求解 (IK)                                         │   │
│  │ 输入: T_base^ee (末端位姿)                                        │   │
│  │ 插件: KDLKinematicsPlugin (从 kinematics.yaml 加载)              │   │
│  │ 算法: Levenberg-Marquardt 迭代优化                                │   │
│  │ 过程:                                                             │   │
│  │   - 初始化: q_current = 当前关节状态                              │   │
│  │   - 迭代: error = ||FK(q) - T_target||                           │   │
│  │   - 更新: Δq = J^+ * error (雅可比矩阵伪逆)                      │   │
│  │   - 收敛: error < tolerance                                       │   │
│  │ 输出: q_goal = [q1, q2, ..., qn] (目标关节角度)                   │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            ↓                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 步骤 3: 碰撞检测                                                  │   │
│  │ 输入: q_start (起始关节状态), q_goal (目标关节状态)               │   │
│  │ 工具: FCL (Flexible Collision Library)                           │   │
│  │ 过程:                                                             │   │
│  │   - 构建 Planning Scene (机器人模型 + 环境障碍物)                 │   │
│  │   - 正运动学: 计算每个 link 的位姿 T_base^link_i = FK_i(q)       │   │
│  │   - 碰撞检测: FCL 检测 link 之间是否碰撞                          │   │
│  │   - 过滤: 使用 SRDF 中的 collision pairs 跳过不需要检测的 link 对│   │
│  │ 输出: 碰撞检测结果 (START_STATE_IN_COLLISION / GOAL_IN_COLLISION)│   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            ↓                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 步骤 4: 路径规划 (OMPL)                                           │   │
│  │ 输入: q_start, q_goal, 约束 (关节限制、碰撞约束)                  │   │
│  │ 规划器: RRTConnect (从 ompl_planning.yaml 配置)                   │   │
│  │ 算法流程:                                                         │   │
│  │   - 初始化: 创建两棵树 T_start 和 T_goal                         │   │
│  │   - 迭代:                                                         │   │
│  │     a) 随机采样 q_rand                                           │   │
│  │     b) 扩展 T_start: q_new = extend(q_near, q_rand)              │   │
│  │     c) 碰撞检测: checkCollision(q_near, q_new)                   │   │
│  │     d) 扩展 T_goal: 类似过程                                     │   │
│  │     e) 连接检查: tryConnect(T_start, T_goal)                      │   │
│  │   - 路径提取: 从起始到目标提取路径                                │   │
│  │ 输出: 几何路径 (waypoints: [q1, q2, ..., qN])                    │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            ↓                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 步骤 5: 时间参数化                                                │   │
│  │ 输入: 几何路径 (waypoints)                                       │   │
│  │ 插件: AddTimeOptimalParameterization                             │   │
│  │ 算法: Iterative Parabolic Time Parameterization                  │   │
│  │ 过程:                                                             │   │
│  │   - 初始时间分配: 根据最大速度限制                                │   │
│  │   - 迭代优化: 检查速度/加速度约束                                │   │
│  │   - 考虑缩放因子: velocity_scaling, acceleration_scaling         │   │
│  │ 输出: 时间参数化轨迹                                              │   │
│  │   trajectory_msgs::JointTrajectory:                              │   │
│  │     - points[].positions: [q1, q2, ..., qn]                      │   │
│  │     - points[].velocities: [dq1/dt, dq2/dt, ...]                 │   │
│  │     - points[].accelerations: [d²q1/dt², ...]                    │   │
│  │     - points[].time_from_start: 时间戳                            │   │
│  └──────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                            ↓ move_group_->execute()
┌─────────────────────────────────────────────────────────────────────────┐
│                        控制器执行 (Fake Controller)                      │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 输入: trajectory_msgs::JointTrajectory                           │   │
│  │ 处理:                                                             │   │
│  │   - 轨迹插值: 从离散轨迹点生成连续运动                            │   │
│  │   - 按时间戳发布关节状态                                          │   │
│  │ 输出: sensor_msgs::JointState (发布到 /joint_states)             │   │
│  │   - name: ["joint1", "joint2", ...]                              │   │
│  │   - position: [q1(t), q2(t), ...] (随时间变化)                   │   │
│  │   - velocity: [dq1/dt, dq2/dt, ...] (可选)                       │   │
│  │ 频率: 50-100 Hz                                                   │   │
│  └──────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                            ↓ /joint_states 话题
┌─────────────────────────────────────────────────────────────────────────┐
│                    robot_state_publisher 节点                            │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 输入: /joint_states + URDF                                        │   │
│  │ 处理:                                                             │   │
│  │   - 解析 URDF，构建机器人运动学模型                                │   │
│  │   - 对于每个 joint，计算子 link 相对于父 link 的变换              │   │
│  │   - 通过 TF 树传播，计算每个 link 在 base_link 坐标系下的位姿     │   │
│  │ 输出: /tf 和 /tf_static 话题                                      │   │
│  │   - 每个 link 的位姿变换 (geometry_msgs/TransformStamped)         │   │
│  └──────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                            ↓ /tf 话题
┌─────────────────────────────────────────────────────────────────────────┐
│                         RViz 可视化                                      │
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ RobotModel Display                                                │   │
│  │ 订阅: /robot_description (URDF), /tf, /tf_static                  │   │
│  │ 处理:                                                             │   │
│  │   - 解析 URDF，构建 3D 模型                                       │   │
│  │   - 订阅 TF，获取每个 link 的当前位姿                             │   │
│  │   - 使用 OpenGL 渲染机器人模型                                    │   │
│  │ 显示: 橙色模型 (当前状态)                                         │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ DisplayTrajectory Display                                         │   │
│  │ 订阅: /display_planned_path (moveit_msgs::DisplayTrajectory)     │   │
│  │ 处理:                                                             │   │
│  │   - 解析轨迹，提取每个轨迹点                                      │   │
│  │   - 使用正运动学计算每个点的末端位姿                              │   │
│  │   - 渲染半透明的机器人模型序列                                    │   │
│  │ 显示: 半透明模型 (规划轨迹)                                       │   │
│  └──────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

## 二、关键数据格式转换

### 2.1 Qt → MoveIt 数据转换

| 阶段 | 输入格式 | 转换过程 | 输出格式 |
|------|---------|---------|---------|
| Qt 用户输入 | x, y, z (m)<br>Roll, Pitch, Yaw (rad) | - | - |
| 欧拉角→四元数 | Roll, Pitch, Yaw | `tf2::Quaternion::setRPY()` | qx, qy, qz, qw |
| 封装 PoseStamped | x, y, z<br>qx, qy, qz, qw | 封装为 `geometry_msgs::PoseStamped` | `geometry_msgs::PoseStamped` |
| Action Goal | PoseStamped + 参数 | 封装为 `PlanExecutePose::Goal` | `PlanExecutePose::Goal` |

### 2.2 MoveIt 内部数据转换

| 阶段 | 输入格式 | 转换过程 | 输出格式 |
|------|---------|---------|---------|
| 坐标变换 | `geometry_msgs::Pose` (frame_id: world) | TF2 变换到 base_link | `T_base^ee` (4x4 矩阵) |
| IK 求解 | `T_base^ee` (末端位姿) | KDL Levenberg-Marquardt 迭代 | `q = [q1, q2, ..., qn]` (关节角度) |
| 碰撞检测 | `q` (关节状态) | 正运动学 + FCL 碰撞检测 | 碰撞检测结果 (bool) |
| 路径规划 | `q_start`, `q_goal` | RRTConnect 算法 | 几何路径 (waypoints) |
| 时间参数化 | 几何路径 | Iterative Parabolic Time Parameterization | `trajectory_msgs::JointTrajectory` |

### 2.3 执行与可视化数据转换

| 阶段 | 输入格式 | 转换过程 | 输出格式 |
|------|---------|---------|---------|
| 轨迹执行 | `trajectory_msgs::JointTrajectory` | 轨迹插值 | `sensor_msgs::JointState` |
| TF 发布 | `JointState` + URDF | 正运动学计算 | `geometry_msgs/TransformStamped` |
| RViz 渲染 | `/tf` + `/robot_description` | OpenGL 渲染 | 3D 可视化模型 |

## 三、关键话题和消息类型

### 3.1 ROS2 Action

- **话题**: `/plan_execute_pose`
- **类型**: `my_arm_config/action/PlanExecutePose`
- **消息结构**:
  ```
  Goal:
    geometry_msgs/PoseStamped target_pose
    float64 velocity_scaling
    float64 acceleration_scaling
    bool execute
    bool wait_for_execution
  
  Result:
    bool success
    string message
  
  Feedback:
    string status
    float32 progress
  ```

### 3.2 关节状态

- **话题**: `/joint_states`
- **类型**: `sensor_msgs::JointState`
- **消息结构**:
  ```
  std_msgs/Header header
  string[] name
  float64[] position
  float64[] velocity
  float64[] effort
  ```

### 3.3 坐标系变换

- **话题**: `/tf`, `/tf_static`
- **类型**: `tf2_msgs::TFMessage`
- **消息结构**:
  ```
  geometry_msgs/TransformStamped[] transforms
    std_msgs/Header header
    string child_frame_id
    geometry_msgs/Transform transform
      geometry_msgs/Vector3 translation
      geometry_msgs/Quaternion rotation
  ```

### 3.4 规划轨迹显示

- **话题**: `/display_planned_path`
- **类型**: `moveit_msgs::DisplayTrajectory`
- **消息结构**:
  ```
  string model_id
  trajectory_msgs/JointTrajectory trajectory
    string[] joint_names
    trajectory_msgs/JointTrajectoryPoint[] points
      float64[] positions
      float64[] velocities
      float64[] accelerations
      duration time_from_start
  moveit_msgs/RobotState trajectory_start
  ```

## 四、调试工具和命令

### 4.1 查看话题数据

```bash
# 查看所有话题
ros2 topic list

# 查看话题信息
ros2 topic info /joint_states
ros2 topic info /display_planned_path

# 实时查看话题数据
ros2 topic echo /joint_states
ros2 topic echo /display_planned_path
ros2 topic echo /tf
```

### 4.2 查看 Action

```bash
# 查看所有 Action
ros2 action list

# 查看 Action 信息
ros2 action info /plan_execute_pose

# 查看 Action 类型
ros2 interface show my_arm_config/action/PlanExecutePose
```

### 4.3 查看 TF 树

```bash
# 查看 TF 树
ros2 run tf2_tools view_frames

# 查看特定变换
ros2 run tf2_ros tf2_echo base_link end_effector_link
```

### 4.4 查看节点信息

```bash
# 查看所有节点
ros2 node list

# 查看节点信息
ros2 node info /moveit_motion_server
ros2 node info /qt_moveit_client
```

### 4.5 查看参数

```bash
# 查看所有参数
ros2 param list

# 查看参数值
ros2 param get /moveit_motion_server planning_group
```

## 五、常见问题诊断

### 5.1 规划失败

**可能原因**:
1. IK 求解失败：目标位姿超出工作空间
2. 碰撞检测失败：起始状态或目标状态碰撞
3. 路径规划失败：找不到无碰撞路径

**诊断方法**:
```bash
# 查看 MoveIt 错误码
ros2 topic echo /moveit_motion_server/result

# 检查 Planning Scene
ros2 topic echo /planning_scene
```

### 5.2 RViz 显示问题

**问题**: 橙色模型没有更新到最终位置

**原因**: 
- `/joint_states` 没有更新到最终状态
- `robot_state_publisher` 没有正确运行

**解决方法**:
```bash
# 检查 joint_states 是否在发布
ros2 topic echo /joint_states

# 检查 robot_state_publisher 是否运行
ros2 node list | grep robot_state_publisher

# 在 RViz 中手动更新
# 点击 "Reset" 或重新订阅话题
```

### 5.3 坐标系问题

**问题**: 目标位姿不正确

**诊断方法**:
```bash
# 查看 TF 树
ros2 run tf2_tools view_frames

# 检查坐标系变换
ros2 run tf2_ros tf2_echo world base_link
```

## 六、数据流验证检查清单

- [ ] Qt 输入数据格式正确（单位、范围）
- [ ] 欧拉角到四元数转换正确
- [ ] Action Goal 成功发送
- [ ] MoveIt 成功接收目标位姿
- [ ] 坐标变换正确（frame_id 存在）
- [ ] IK 求解成功（验证 FK 结果）
- [ ] 碰撞检测通过
- [ ] 路径规划成功
- [ ] 时间参数化正确
- [ ] 轨迹成功下发到控制器
- [ ] `/joint_states` 正确发布
- [ ] `/tf` 正确发布
- [ ] RViz 正确订阅和渲染

## 七、参考资料

1. **MoveIt2 官方文档**: https://moveit.picknik.ai/
2. **OMPL 文档**: https://ompl.kavrakilab.org/
3. **KDL 文档**: https://www.orocos.org/kdl.html
4. **FCL 文档**: https://github.com/flexible-collision-library/fcl
5. **ROS2 官方教程**: https://docs.ros.org/en/humble/

